\documentclass[12pt, a4paper]{article}

\include{inc/packages.inc}
\include{inc/personalize.inc}
\include{inc/style.inc}


% \pagestyle{plain}
\pagestyle{fancy}
\fancyhf{}
\fancyhfoffset[L]{1cm} % left extra length
\fancyhfoffset[R]{1cm} % right extra length
\rhead{\thepage}
\lhead{\nouppercase\leftmark}
\cfoot{\fancyplain{}{\thepage} }

\begin{document}

\pagenumbering{gobble}
\include{inc/title.inc}

\tableofcontents
% \newpage
\newcounter{lastroman}
\setcounter{lastroman}{\value{page}}

\pagenumbering{arabic}
\maketitle
\begin{abstract}
    \textbf{English:} \lipsum[20]
\end{abstract}
\begin{abstract}
    \textbf{Deutsch:} \lipsum[20]
\end{abstract}
\newpage
\section{ Introduction}
    \subsection{Scope of the thesis}
    \subsection{Goal of the theses}
    \subsection{Structural overview}
    \newpage
\section{Container and DevOps Basics}
    \subsection{What is DevOps}
    Agile software development is a practice that was popularized by the \wordhighlight{'Manifesto for Agile Software Development'}, written by various authors~\cite{manifesto}. It prioritizes the rapid adoption to changes and continuous evolution of software over a predefined plan and contract negation.
    The four core principles are:
    \begin{itemize}[label=\(\star\)]
        \item \textbf{Individuals and interactions} over processes and tools
        \item \textbf{Working software} over comprehensive documentation
        \item \textbf{Customer collaboration} over contract negotiation
        \item \textbf{Responding to change} over following a plan
    \end{itemize}
    The entire manifest is the foundation of several software development mythologies and frameworks supporting these strategies, such as \wordhighlight{SCRUM} and \wordhighlight{\ac*{XP}}.
    \subsection{Container and Microservice basics}
    The fundamental idea of Microservices is to have independently deployable small software applications. If the load on the part of the application increases new instances of the application can be deployed to balance to load across all instances. This concept requires a fast and reliable process to create new application instances.\newline
    The installation and setup process of new hardware can be a time-consuming task. To reduce the amount of time it takes to create new application instances, the software industry uses the concept of virtualization.\newline
    Virtualization is an abstraction layer. The physical hardware (called host) runs a hypervisor that allows the execution of (multiple) virtual machines (called guests) that act like a regular computer \cite{vmbasics}. This approach allows the usage of heterogeneous hardware without an impact on the guest operating systems thanks to the abstraction provided by the hypervisor. Without the need for specialized hardware and the dynamic allocation of resources, efficiency is also increased \cite{redhat_venv}. Additionally, virtual systems can be managed more easily because fundamentally they are just one big file on the hosts' storage device. They can be created on command, cloned and deleted without the configuration steps of a physical system. In the enterprise industry it is common to use this flexibility to start additional \ac{VM}s on high load. In fact according to a study by \ac{IDC} more than 80\% of datacenter workloads are virtualized \cite{virtualaddoption}. Virtualization also comes with the benefit of security. The majority of hypervisors strictly separate the host and the guest system. The guest system is not allowed to use the hosts resources and access its files unless it is explicitly configured to do so. Compromising a \ac{VM} does not affect the host or any other \ac{VM}s \cite{redhat_venv}.\newline
    Full guest virtualization emulates a complete \ac{OS}, including the kernel, system libraries  and even the majority of hardware devices. This abstraction comes with a performance penalty called overhead. SEARCH OVERHEAD PERCENTAGE. A more lightweight approach of virtualization is called containerization. This approach focuses on the isolation of one application in a virtual runtime. Unlike \ac{VM}s, system and kernel functions are not virtualized and are passed through to the host machine. The result is a reduction of overhead and the ability to run additional application instances compared to \ac{VM}s with the same amount of compute resources. Fig. \ref{fig::vm_docker} visualizes the differences between these approaches.
    \begin{figure}
        \centering
        \includegraphics[width=0.9\textwidth]{docker-vm-redhat.png}
        \caption{\ac{VM}s compared to Containers \\\textit{Source: \cite{redhat_pic}}}\label{fig::vm_docker}
    \end{figure}
    \subsection{\acl{CI} and \acl{CD} concepts}
    \subsection{Containerization in development environments}
\section{Concept of DevContainers}
    \subsection{Pre-requirements for DevContainers}
    \subsection{Description of a conceptual environment}
    \subsection{Available tools and resources}
    \subsection{Possible implementations approach's}
    \subsection{Strengths, weaknesses and limits}
\section{Exemplary implementation process}
    \subsection{Current state and goal}
    \subsection{Implementation approach}
    \subsection{The implementation process}
    \subsection{Encountered challenges and limits}
    \subsection{Final state}
\section{Performance evaluation and analysis}
    \subsection{Metrics and what to evaluate}
    \subsection{Evaluation and results}
    \subsection{Discussion of evaluation}
\section{Future potential and outlook}
\section{Conclusion}

\newpage
% Anhang
\lhead{Appendix}
\renewcommand{\thesubsection}{\Alph{subsection}}
\pagenumbering{Roman}
\setcounter{page}{\value{lastroman}}
\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}

%Abk√ºrzungsverzeichnis
\input{inc/shorts.inc}
\newpage

%Code
\input{inc/code_template.inc}
\newpage
\listoffigures


%Bibliographie
\addcontentsline{toc}{section}{References}
\bibliographystyle{IEEEtranSA}
\bibliography{bib/sources}
\include{inc/ensure.inc}

\end{document}