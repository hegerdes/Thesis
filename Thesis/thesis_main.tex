\documentclass[12pt, a4paper]{article}

\include{inc/packages.inc}
\include{inc/personalize.inc}
\include{inc/style.inc}

% \pagestyle{plain}
\pagestyle{fancy}
\fancyhf{}
\fancyhfoffset[L]{1cm} % left extra length
\fancyhfoffset[R]{1cm} % right extra length
\rhead{\thepage}
\lhead{\nouppercase\leftmark}
\cfoot{\fancyplain{}{\thepage} }

\begin{document}

\pagenumbering{gobble}
\include{inc/title.inc}
% For printing add this
\newpage\null\thispagestyle{empty}\newpage

% Title & Abstract
\maketitle
\begin{abstract}
    \textbf{English:} \lipsum[20]
\end{abstract}
\begin{abstract}
    \textbf{German:} \lipsum[20]
\end{abstract}
\newpage

% Table of Contents
\tableofcontents
\newpage

% Normal page numbering
\newcounter{lastroman}
\setcounter{lastroman}{\value{page}}
\pagenumbering{arabic}

% Line spacing
% \onehalfspacing{}

\section{Introduction}\label{sec::intro}
Industry 4.0 is here and due to the covid-19 pandemic the need for digital business solution is bigger than ever before. To provide fast and suitable software solutions developers need adequate development setups, also called development environments. This thesis analysis modern agile software development environments point out potential problems and purposes a virtualized software development solution.\newline
This section provides an overview about this thesis. It will briefly describe the fundamental core question of this thesis, point out its relevance and presents a possible solution approach. Subsequently, a clear delineation is then given as to what is and is not covered in this thesis. The last section of the introduction gives a structural overview of how the thesis is structured and how it will approach the given problem.
    \subsection{Structural Overview}
    This section gives an initial overview and delineations to this thesis. Following this section there is a description of the main topic of this work and the goal that should be achieved. Section \ref{sec::backgrund} provides overall background information which are recommended for further understanding. Common and modern development methodologies are described in section \ref{ssec::devops}, followed form Microservice and Container basics in section \ref{ssec::microservices} and \acl{CI} tools in \ref{ssec::ci_cd}. In section \ref{sec::problem} will be a detailed analysis of current development setups and the problems encountered in these setups. Section \ref{sec::solution_concept} provide a conceptual solution approach and  defines conditions for such a solution. This concept is applied in section \ref{sec::solution_code} by implementing in a practical reference project. Section \ref{sec::eval} discusses the proposed solution and shows its advantages and disadvantages. At the end, a potential outlook on future application possibilities or alternative solutions is given in section \ref{sec::outlook}, followed by the conclusion in section \ref{sec::conclusion}.
    \subsection{Problem Description}
    The rise of Agile development and Microservices was accelerated by the emergence of new technologies that changed the way \textit{where} and \textit{how} software is running. Applications could be distributed and scaled quickly through the cloud which benefited customers favors for quick changes. Yet the actual coding setup has not changed significantly.\newline
    Requirements for development environments differ depending on the project type. Development of (\acs{GUI}) applications for PC's and Smartphones is quiet different to web-services development. As the functionality of web services continues to grow and they are a cost-effective way to deliver a product across platforms, this method is becoming increasingly popular. However, the operating system used for development often differs from the operating system used to run the application. This can cause platform dependent errors. The use of a microservice architecture, due to its easy scalability, adaptability and rapid development, brings further problems. Microservices require additional configuration effort and increases the difficulty level for whole system tests, also called end-to-end tests. The initial setup for new developers can get quiet complex, requires time and might even discourage developers in open source projects.\newline
    These characteristics add additional effort, can introduce new errors and slow down the development speed, resulting in higher cost and lower customer experience.

    \subsection{Scope of the Thesis}
    \subsection{Goal of the Theses}
\section{Background Information about Agile, Container and Microservices}\label{sec::backgrund}
The following section provides some basic definitions and principles that are necessary for the further understanding of this paper and ensures a common level of knowledge of these topics.\newline
First of will be a formal definition of DevOps, a brief description of the emergence and its current state.
    \subsection{Modern Methodologies: Agile and DevOps }\label{ssec::devops}
    This section provides a formal definition of agile software development Paradigms and the DevOps methodology, explains their connection and points out the fundamental principles of a DevOps enabled culture. These principles and their workflows will be revisited in section~\ref{sec::solution_concept} as part of the proposed solution concept.

        \subsubsection{Agile Development}
        Agile, just like the \wordhighlight{V-Model}, \wordhighlight{Waterfall} and \wordhighlight{Prototyping} model, is a software development paradigm. It was proposed and popularized by the \wordhighlight{"Manifesto for Agile Software Development"}, written and published in 2001 by various authors~\cite{manifesto}. Rapid adoption to changes, continuous evolution of software and customer communication are the fundamentals of agile software development.\newline
        The four core principles are:

        \begin{itemize}[label=\(\star\)]
            \setlength\itemsep{0em}
            \item \textbf{Individuals and interactions} over processes and tools
            \item \textbf{Working software} over comprehensive documentation
            \item \textbf{Customer collaboration} over contract negotiation
            \item \textbf{Responding to change} over following a plan
        \end{itemize}

        \noindent Paradigms like Waterfall describe a comprehensive model with a detailed requirements analysis and architecture design phase. This results in a fixed and detailed sequential schedule for the implementation, testing and requirements fulfillment verification phase. Errors in the requirements analysis or changes in requirements can cause difficulties later phases of the project. Agile on the other handle only provides guidelines instead of a complete model. Changes are expected and the project realization is designed to be adaptable. Project phases such as implementation and testing run together and the entire \ac{SDLC} is kept shorter and more adaptive \cite{agile_practice}.\newline
        Agile provides a mindset for projects with uncertain or continuous changing requirements. Accordingly, the agile manifesto became the foundation of several software development mythologies and frameworks that extend these fundamental guidelines and provide additional workflows and tooling for the software creation process. Well known examples are methodologies such as \wordhighlight{SCRUM}, \wordhighlight{\ac*{XP}} and \wordhighlight{DevOps}.

        \subsubsection{DevOps Definition}
        DevOps is a set of practices in software development hat aims to increase costumer value and software quality by shortening the development life cycle through active collaboration and continuous delivery of improvements \cite{base_devops}, \cite{effective_devops}. The term \wordhighlight{DevOps} is a neologism from development (Dev) and operation (Ops). The combination of these terms is symbolic for the tighter collaboration between the development and operations team, which were previously strictly separated. Therefore, DevOps is considered more than just software development principles, it is called a mindset and company/development culture. Shorter development times and closer collaboration are goals of agile software development paradigm. DevOps builds upon the guidelines and goals of agile and offers additional workflows and tools for software development to increased user experience value \cite{azuredevops}, \cite{effective_devops}.

        \subsubsection{Principles of DevOps}\label{ssec::devops_princibles}
        DevOps builds upon the agile principles. It extends the \wordhighlight{\acl{XP}} approach by also applying its principles to the operations and infrastructure aspects of the application \cite{effective_devops}. The goal is to provide a structured and comprehensive process from coding up to application monitoring. This process is referred to as a workflow and the minimal steps in an exemplary workflow are shown in table~\ref{tab::devops_steps}~\cite{base_devops}.\newline

        \begin{table}[!h]
            \centering
            \begin{tabularx}{0.85\textwidth}{llX}
                \multicolumn{2}{l}{Step} & Description \\ \hline\hline
                1 & \textbf{Coding}& Code development \& review and source control.  \\
                2 & \textbf{Building}& \acs{CI} build and build status.  \\
                3 & \textbf{Testing}& \acs{CI} testing and testing feedback.  \\
                4 & \textbf{Packaging}& Bundle and package to a central registry.  \\
                5 & \textbf{Releasing}& Release management, approvals and automation.  \\
                6 & \textbf{Configuring}& Infrastructure configuration and management.  \\
                7 & \textbf{Monitoring}& Applications performance monitoring.  \\
            \end{tabularx}
            \caption{DevOps workflow steps.}
            \label{tab::devops_steps}
        \end{table}

        \noindent With such a workflow come tasks that are the core procedures in a DevOps environment. These tasks include configuration management, release management, \ac{CI}, \ac{CD}, \ac{IaC}, test automation and application performance monitoring~\cite{azuredevops}.\newline
        For the scope of this work, only solutions from configuration management, \ac{CI} and \ac{IaC} will be used to enable a homogeneous development environment. The configuration management is about versioning the applications runtime environment and how to set it up. It determines on how the application interacts with system and external interface services. Common configuration parameter are the compiler/interpreter version, resources and permission settings as well as domain-names or \acs{IP}-addreses of other (external) services \cite{base_devops}. A DevOps principled architecture has multiple deployment stages. A staging and live environment is considered minimal base of any such projects. Adding a local environment increases the overall amount configuration effort, requiring a reliable, efficient way to manage it. This is closely related to the \ac{IaC} principle, which describes the provisioning process of computing resources. Tools like Ansible, Puppet and Terraform can automatically create and set up new cloud \ac{VM}s specified in a playbook. Playbooks are structured policies written in a custom language which are also stored in version control \cite{ansible2020}, \cite{azuredevops}.\newline
        These files describe how the host operating system is configured. Changes on these files can be handled the same way as regular code, starting with a pull request, reviews, test and approval of the changes. The \acl{IaC} principle will later be used to properly handle the setup of development containers, next to the \acs{CI} tools wich are described in section \ref{ssec::ci_cd}.

    \subsection{Container and Microservice Concept}\label{ssec::microservices}
    The following section provides a basic understanding about the concepts of Microservices and what principles are used to enable these.

        \subsubsection{Fundamental Idea of Microservices}
        The fundamental idea of Microservices is to have small independently deployable software applications. Connections between these applications make it possible to provide a greater service with an extensive range of functions \cite{micro}. An exemplary structure of a microservice cluster is visualized in figure \ref{fig::micro}. It shows multiple Microservices that each expose one functionality to the outside world. Application end-points such as a \ac{UI} provide a broad function range by internally calling multiple Microservices. In the event of one application failure, only that specific functionality becomes unavailable, the remaining system keeps operational. Because of this architectural design feature is advised that, while working with data, each microservice has its own Database. This prevents having a central database becoming a single point of failure. Another core feature of Microservices in its scalability. If the load on one part of the service increases, new instances of that application can be deployed to balance to load across all instances. This concept requires a fast and reliable process to create new application instances.\newline
        The installation and setup process of new hardware can be a time-consuming task. To reduce the amount of time it takes to create new application instances, the software industry uses the concept of virtualization.

        \begin{figure}
            \centering
            \includegraphics[width=0.5\textwidth]{monolithic-vs-microservices_altered.png}
            \caption{Structure of Microservices - [Altered], \\\textit{Source:~\cite{redhat_micro}}}\label{fig::micro}
        \end{figure}

        \subsubsection{Virtualization and Containerization}
        Virtualization is an abstraction layer. The physical hardware (called host) runs a hypervisor that allows the execution of (multiple) virtual machines (called guests) which act like a regular computer \cite{vmbasics}. This approach allows the usage of heterogeneous hardware without an impact on the guest operating systems thanks to the abstraction provided by the hypervisor. Without the need for specialized hardware and the dynamic allocation of resources, efficiency is also increased \cite{redhat_venv}. Additionally, virtual systems can be managed more easily because fundamentally they are just one big file on the host's storage device. They can be created on command, cloned and deleted without the configuration steps of a physical system. In the enterprise industry it is common to use this flexibility to start additional \ac{VM}s on high load. According to a study by the \ac{IDC} more than 80\% of data center workloads are virtualized \cite{virtualaddoption}. Virtualization also comes with the benefit of security. The majority of hypervisors strictly separate the host and the guest system. The guest system is not allowed to use the hosts resources and access its files unless it is explicitly configured to do so. Compromising a \ac{VM} does not affect the host or any other \ac{VM}s \cite{vmbasics}, \cite{redhat_venv}.\newline
        Full guest virtualization emulates a complete \ac{OS}, including the kernel, system libraries and even the majority of hardware devices. This abstraction comes with a performance penalty called overhead \cite{vmbasics}. A supposedly more lightweight approach of virtualization is called containerization. Studies by Ericsson Research, Nomadic Lab \cite{ieee_perfomance} and the Zhengzhou University \cite{zhengzhou_university} conclude in fact that container based solution provide better performance especially in disk \acs{I/O} and network \acs{I/O} bound scenarios. Containerization focuses on the isolation of one application process in a virtual runtime using control groups and namespace technologies \cite{cgroups}. Unlike \ac{VM}s, system and kernel functions are not virtualized and are passed through to the host machine. The result is a reduction of overhead and the ability to run additional application instances compared to \ac{VM}s with the same amount of compute resources. Figure \ref{fig::vm_docker} visualizes the differences between these approaches. The left side shows a traditional \ac{VM} based approach, on top of the host \ac{OS} runs a hypervisor which provides three full guest \acl{OS}s each with one application. Each gust is fully isolated and with its own kernel, \ac{OS} and runtime libraries. The container based solution only needs the host \ac{OS} and provides multiple application instances with shared libraries and runtimes in separated, isolated namespaces.\newline
        Apart from the performance benefits, the presumably main advantage of containers is their scalability~\cite{cintainer_scale}. Which makes them an adequate fit for Microservices. The most popular container based virtualization solutions are Docker, Podman and LXC.

        \begin{figure}
            \centering
            \includegraphics[width=0.9\textwidth]{docker-vm-redhat.png}
            \caption{\ac{VM}s compared to Containers, \\\textit{Source:~\cite{redhat_pic}}}\label{fig::vm_docker}
        \end{figure}

        \subsubsection{Usage of Containerization in Microservices}
        As described above, microservices are small applications that communicate with each other. To follow the principles for loose coupling between the applications the communication should be performed over a programming language independent protocol. Typical \acs{IP} network protocols used are \ac{REST}, WebSockets or GraphQL \cite{micro}. These loose coupled applications have the advantage that they can be development simultaneously from different teams as well as upgraded and replaced independently. As a result, applications can be developed much faster and more flexibly, following the principles of agile development \cite{micro}, \cite{redhat_micro}.\newline
        The usage of containers brings this speed and flexibility even further. Containers provide a consistent, isolated yet flexible runtime for applications \cite{micro_container}. Applications are packaged within known good runtimes. This reduces the setup time of the deployment and eliminate host specific errors. New application instances can be started without additional configuration. As a result of the successful concepts, tools like Docker Swarm and Kubernetes have been developed that can scale distributed applications in a managed dynamic, even automatic way.\newline
        \noindent Packaging and eventually even deploy the application introduces additional work for developers that was previously the task of the operations team. As already stated above, the developer and operations team are not separated in a DevOps culture. The new focus places value on team communication, flexibility and autonomy provided by the automation and support of as many steps as possible between the development and operation workflow \cite{effective_devops}. Eliminating manual tasks allows developers to focus on the actual application development. One of the main concepts in this process is the usage of \ac{CI} and \ac{CD} workflows.

    \subsection{Continuous Integration and Continuous Delivery Concepts}\label{ssec::ci_cd}
    \acl{CI} and \acl{CD} are two working concepts that are particularly well known in microservice architecture. Since every service provides only one part of the overall application functionality, it is uncertain what effects a change in one service has to other services and the wohle application.\newline
    \acl{CI} is a practice where new code is regularly integrated into the main code branch. Instead of having isolated functional branches that are worked on independently for months, changes flow back regularly to ensure it is free from conflicts and errors. Especially in interconnected services, it is important to ensure that a change in one service does not have an unintended effect on other services. \ac{CI} systems usually perform these integration tasks, as well as the associated tests automatically. In case of an error it becomes easier to identify the source error, due to these small and continuous integrations.\newline
    \acl{CD} on the other hand is a practice to bring these regular updates quickly and automatically into production. To ensure product quality, it is best to have multiple deployment environments, as described in section~\ref{ssec::devops_princibles}. Each new version is automatically deployed to a test or development environment where it undergoes automatic or manual testing. If the tests are successful, the version is promoted to the next deployment environment. In case of an error, the version is discontinued and the developers are notified about it. Only if all previous environments have not revealed any errors, the version will be transferred to production as a new release. Figure \ref{fig::cd} visualizes such a \ac{CD} pipeline. \newline
    Both \ac{CI} and \ac{CD} are practice to automate tasks that have previously been performed manually. Integration testing and packaging have both moved to a dedicated, autonomous system, giving developers and operators more time for other activities.
    \input{inc/tikz_cd.inc}

\section{Analysis of the current State of Development Environments}\label{sec::problem}
The following section will display the current status of a typical \ac{DevEnv}, point out its problems and provides approaches for possible solutions.

\subsection{Current State of Developer Environments}
    Software development involves a broad variety of tasks. Depending on the project, tasks can range from pure web development, desktop or mobile application development, embedded system development or the pure maintenance of one of these variants. Each of these software development fields has its own workflows and requirements for the actual development setup. Even within these specialties, there are different requirements, depending on the scope, size, power and general capability demand for the project. Accordingly, development environments setups can differ greatly from one another.
    % Generalle Anforderung:
    % Fokus auf code nicht auf config.
    % Reproduzierbakeit
    % Kosten
    % Umgebung ist managbar

    % With the rise of cloud services the software development cycle accelerated. With services such as \ac{AWS}, Microsoft Azure and Google Cloud Computing it became possible to provision compute resources automatically and on demand. It changed the way \textit{where} and \textit{how} software is running.\newline
    % TODO
    \subsection{Common Issues in Modern Development Setups}
        \subsubsection{Additional Development Effort}
        \subsubsection{Issues Caused by Heterogeneous \acs{DevEnv}'s}
        \subsubsection{Operating System Specific Tools and Errors}
        \subsubsection{Dependencie Management}
        \subsubsection{Missing End-to-End Test Possibilities}
    \subsection{Propsed solution}

\section{Solution Concept of DevContainers}\label{sec::solution_concept}
    \subsection{Pre-requirements for DevContainers}
    \subsection{Description of a Conceptual Environment}
    \subsection{Available Tools and Resources}
    \subsection{Possible Implementations}
    \subsection{Strengths, Weaknesses and Limits}

\section{Exemplary Prototype Implementation}\label{sec::solution_code}
    \subsection{Current State and Goal}
    \subsection{Implementation Approach}
    \subsection{The Implementation Process}
    \subsection{Encountered Challenges and Limits}
    \subsection{Final state}

\section{Performance Evaluation and Analysis}\label{sec::eval}
    \subsection{Metrics and how to Evaluate}
    \subsection{Evaluation and Results}
    \subsection{Discussion of Evaluation}

\section{Future Potential and Outlook}\label{sec::outlook}
\section{Conclusion}\label{sec::conclusion}

\newpage
% Anhang
\lhead{Appendix}
\renewcommand{\thesubsection}{\Alph{subsection}}
\pagenumbering{Roman}
\setcounter{page}{\value{lastroman}}
\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}

%Abk√ºrzungsverzeichnis
\input{inc/shorts.inc}
\newpage

%Code
\input{inc/code_template.inc}
\newpage
\listoffigures
\listoftables


%Bibliographie
\addcontentsline{toc}{section}{References}
\bibliographystyle{IEEEtranSA}
% \bibliographystyle{alpha}
\bibliography{bib/sources}
\include{inc/ensure.inc}

\end{document}