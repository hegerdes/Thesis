% !TeX root = ../thesis_main.tex

\section{DevContainer Analysis and Evaluation}\label{sec::eval}
In the following section discusses the usability of DevContainers and compares them with alternative virtualization-based development solutions. The metrics considered for this are described below and are then used to evaluate the success of the solution described in this thesis.

    \subsection{Considered Metrics}
    The evaluation is divided into two sections. It is examined whether DevContainers were able to solve the problems described in section \ref{sec::problem} and the usability impact of the challenges, encountered during the prototype implementation, are analyzed. Subsequently, DevContainers are compared to alternative solutions, which just exist on the market. For this purpose, the alternatives described in section \ref{ssec::alternatives} are taken into account.\newline
    For the evaluation of the DevContainer prototype in the Symbic project, several metrics are taken into account. One of the first things to look at is the number of steps that need to be taken to deploy all the necessary components of the system to the developer's machine. This approximates the expected effort for new developers to get a working project setup. Platform specific steps are also considered as well as the number of available programs. Subsequently, the interaction with the environment is analyzed. The choice of the editors and the presence of obstacles when interacting with the applications is taken into account. The system load is also taken into account here. This clarifies whether the properties of the DevContainers have a significant impact on the development work. Finally, the behavior in case of failure, the reproducibility and test possibilities are considered. \newline
    When comparing to the alternative development environments mentioned in section \ref{ssec::alternatives} the main comparison is made between the function range. This includes control over the environment, supported programming languages, the type of service provision and the pricing model.

    \subsection{Evaluation and Results}\label{sses::eval_compare}
    This section examines and evaluates the metrics and data collection points mentioned above. This takes place divided into two sections, first the evaluation of data for the prototype implementation of the DevContainer concept. The traditional/native development environment is directly contrasted with the DevContainer environment.
    In the absence of a direct comparison, the second section compares the DevContainer environment argumentatively with alternative solutions, both browser-based and container-based.

        \subsubsection{Evaluation for the Prototype Implementation}
        The following is an evaluation of the success of the DevContainer with respect to the problems described in Section \ref{sec::problem}.

        \myparagraph{The Initial Setup Process}
        The initial setup process is significantly simplified with DevContainer. Databases and auxiliary services are all provided by containers, so there is no need to install them manually. Language runtimes, compilers and dependencies provided with the DevContainers images. Specific versions of every software used, are all stored as code, so that, similar to the PaaS principle, the entire development environment is made available as a uniform platform.\newline
        Table \ref{tab::init_steps} shows' a comparison of all the steps which need to be performed, by new developers, in order to create a working environment. Cloning the repositories and installing an editor is necessary in both approaches, but while the native development approach requires all program components to be installed individually, the DevContainer environment requires only Docker to be installed. Accordingly, less than half of the steps are necessary for the DevContainer approach. The table also takes into account whether the respective steps are independent of the \acl{OS}. All steps with a (dark) green background are independent of the operating system used. The steps with a gray background are \acl{OS} specific and therefore potentially different for each \ac{OS} and more error-prone.\newline
        DevContainers therefore make it much easier to set up a new working environment. After installing Docker, all applications can be started by calling \code{docker-compose up}.
        \input{inc/table_init.inc}

        \myparagraph{Dependency Management}
        Due to the firmly defined Dockerfiles, the version of the programming languages used is always consistent among all developers. Errors caused by different versions of libraries are thus avoided. If a new major program version is to be tested, developers can simply set the \code{VARIANT} variable accordingly and restart the DevContainer with the \code{--build} flag of Docker Compose (\code{docker-compose up --build}). A new image is automatically created and the application is launched with the new runtime without affecting other applications or the host. This strict isolation of individual versions greatly simplifies the parallel operation of multiple versions and prevents errors.\newline
        In case an error in the environment configuration occur anyway, it can be quickly fixed by discarding the existing DevContainer and recreating a new one from a known good image. Changes to the source code are not lost, since these are stored on the host and are available by bind-mount in the container.
        The number of possible problems is significantly reduced by the use of DevContainer. The DevContainer environment is very similar to the configuration in productive operation. Operating system specific errors, such as different file system separators, line endings and libraries that may behave differently between Linux and Windows, are avoided. Developers can focus on the functions of an application and do not have to consider as many edge cases when running their application.

        \myparagraph{Lack of Testing Options}
        A major challenge of a microservice architecture is the increased configuration overhead between applications and the associated lack of test for the entire service. Besides unit tests, developers could not test the integration of individual applications due to the immense configuration effort. Because of this, the job is often done by \ac{CI} systems. However, these systems can only detect errors after the code has been checked in and all, possibly lengthy, tests have been completed.\newline
        However, thanks to DevContainers and the orchestration of individual services by Docker Compose, all relevant applications can be launched and interact with each other within a short time. Thus, end to end tests can already be performed on the developers' machines. Errors can be detected before check-in into the \ac{VCS} and thus be fixed earlier. Through the use of containers, even more comprehensive testing tools may be available.\newline
        However, the devcontainer concept does not replace testing by the CI.  Load tests and acceptance tests cannot be carried out on the developer's computer, since its results have no relevant significance. The solution presented here also does not take into account communication via \code{HTTPS}. Certificate-related errors will therefore not be avoided by DevContainer.

        \myparagraph{Performance Evaluation}
        ToDo

        \myparagraph{Further Potential and Possible Improvments}
        Docker enables access to programs, which were previously exclusively available in the server world, the concept presented here can be further improved. Instead of exposing application ports, a reverse proxy can be placed in front of the applications. This then allows developers to access their frontend by calling \code{forntend.myapp}. Developers do not need to remember application ports or have to pay attention to port collisions on \code{localhost}. The reverse proxy routes all requests to the appropriate application. To minimize the load on the developer's machine, shared utilities can be made available and shared on a company internal server in the future. Further potential for improvement exists in the interaction between host computer and container in Windows-based systems. The differences in the file systems must be taken into account when creating a DevContainer setup and can impair its use in certain cases.


    \subsubsection{Comparison to Alternative Development Solutions}
    The evaluation is based on the available documentation and experiences made while testing these solutions at the time of writing this paper. The solution presented in this paper is compared with browser-based and container-based development environments of various vendors. The results of the following comparison is summarized at the end of this section in Table \ref{tab::env_compare}.

        \myparagraph{Comparison to browser-based Development Solutions}
        The major distinction between the solutions presented in this thesis and browser-based development environments is the scope of supported programming languages. The alternatives Codesandbox.io and Stackblitz, presented above, only support NodeJS projects based on JavaScript or its superset TypeScript. The choice of programming language is accordingly limited, as is the ability to run multiple services in parallel. Both services lack the possibility of orchestration, as well as the installation of any additional utilities, which greatly limits the control over the environment. \newline
        Furthermore, not all functions of NodeJS are supported. External packages based on native \acl{OS} libraries or binaries, like the popular task-runner \code{grunt}, often do not work. This is especially true for packages based on encryption, like the \ac{SSH}-client \code{ssh2}. Control over created network sockets is either missing or limited by the browser runtime. A command-line interface is missing (Codesandbox.io) or very limited (Stackblitz). Both solutions do not support debugging. Due to the browser window, the available space in the editor is limited by an always present preview window and common key combinations like \code{F1} collide with the browser keyboard shortcuts.\newline
        The advantage of this solution is that users have a working setup within seconds, due to the variety of templates. Users can edit in the browser from any device without the need to install additional programs. This makes this solution attractive for teaching purposes and fast prototyping of frontend projects. Since Codesandbox.io, unlike StackBlitz, runs the code on its servers, Codesandbox.io has access to the entire source code and network traffic, which may violate confidentiality clauses. Their free pricing models only allow for public accessible development sessions and no support for private package repositories. Paid sessions vary from \$9 to \$39 for Stackblitz and \$30 to \$50 for Codesandbox.io per user per month \cite{stackblitz}, \cite{codesandbox}. \newline
        These solutions also try to solve problems in modern development environments, but limit themselves to a specific scope. The limitations listed here show that only small NodeJS projects or pure frontend projects can be implemented with Codesandbox.io and Stackblitz. This is also supported by the fact that the majority of templates are build for frontend frameworks. The lack of function for backend projects and the missing support for auxiliary services make these alternatives not suitable for professional development.

        \myparagraph{Comparison to container-based Development Solutions}
        The alternative container-based development environments Codespaces and Gitpod show distinct similarities to the solution presented in this thesis. Both solutions rely on the isolated provisioning of predefined runtime environments via container-based virtualization. These environments are likewise built upon a Linux kernel and can thus provide a development environments for any programming language supported on Linux. Projects that require Windows or macOS are not supported.\newline
        Gitpod is integrated in various \ac{VCS}-providers and offers the possibility to create a \ac{VSCode} instance within the browser. A local \ac{VSCode} instance can also be used in order to connect to a running container, this bypasses the limited keyboard shortcuts available in a browser. Codespaces offers the same possibility, except that this service only works with GitHub.com. Within the containers, developers have full control over the system. Additional applications can be installed, debugging is possible and ordinary TCP/UDP ports can be exposed to the Internet or to the client device.\newline
        However, Codespaces and Gitpod differ in the way individual applications are organized. Both alternatives focus on the provision of one development environment for one application, while the DevContainer concept specializes in the simultaneous usage and interaction of multiple applications. Codespaces, Gitpod and the DevContainers all require that the container environment to be once manually defined and optimized. The time required is determined by the size and complexity of the project. While one container can contain any number of services this accordingly requires the resources necessary for this. Codespaces can enable a development environment for massive applications like the monolithic structured GitHub.com service (13 GB repository and many dependencies) when given 32 CPU cores and 64 GB RAM \cite{githubblogcodespace}, but this is not necessary if developers only work on one part of the project. GitHub struggled primarily with the deployment time of the container, through intensive optimization they were able to reduce the creation time from 45 minutes to less than a minute. The provisioning time of the DevContainer solution is about 10 seconds, provided that the images have already been downloaded once. In contrast to the solution presented here, hybrid operation between local applications and DevContainer applications cannot be implemented. This presents companies with a major decision, whether to invest all their capacities in this type of development in one fell swoop instead of switching gradually. \newline
        Further, differentiating the solutions is their choosing of editors. The use of \ac{VSCode} is recommended, but unlike Codespaces and Gitpod, developers can also opt for any other editor, as the code remains on the developer's computer. With Codespaces and Gitpod, the container infrastructure is provided by the respective providers, so a permanent Internet connection is required and compliance with confidentiality agreements must be checked. Both services also offer options for self-hosting, but these are only included in the higher-priced subscriptions. The free versions used for the evaluation either offer only limited computing time, such as the 50 hours per month at Gitpod, or the computing capacity used is billed per minute. The paid offerings range per month and user from \$9 to \$39 for Gitpod and \$4 to \$21 for Codespaces. The DevContainer solution presented here is free as long as the company size does not exceed 250 employees or a turnover of \$10 million when using Docker Desktop. After that, prices are charged between \$5 and \$21 \cite{gitpod}, \cite{githubblogcodespace}.\newline
        Structurally, all three solutions are similar in various points, the usability of CodeSpaces is superior due to its direct integration in \href{https://www.GitHub.com}{GitHub.com} and the resulting comfort. The massive hardware resources of Codespaces and Gitpod are not comparable with those of a developer workstation. The biggest disadvantage of these solutions is the dependence on an external service provider and the associated significantly higher costs. The existence of these solutions and the increasing number of providers conclude the potential of efficient and uniform development environments. Codespaces was only officially presented and made available during the preparation of this work and is still at an early stage. Which of the presented solutions is the most suitable for a project depends on the respective requirements. Since all three solutions do not rely on proprietary solutions, the same Docker files can be used for DevContainer, Codespaces and Gitpod. This enables easy migration between these solutions.


    \subsection{Summarized Evaluation}
    As seen above, DevContainers offer a tremendous opportunity to solve problems during development time. Development environments become more isolated, uniform and much easier to set up. The commercial solutions such as Codespaces and Gitpod show that these companies see potential in using pre-established development environments. \newline
    The solution presented here was able to solve the problems described in section 3 to a large extent and can be classified as successful. Although the creation of a DevContainer environment increases the configuration effort in the short term, in the long term fewer different configurations setups need to be supported. \newline
    The possibilities of virtualization in development are enormous. Suddenly, a much larger selection of programs is available, which are already preconfigured. Even if no DevContainers are used for the applications to be developed, the simple provision of databases and auxiliary services is an immense advantage.
