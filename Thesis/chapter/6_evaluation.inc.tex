% !TeX root = ../thesis_main.tex

\section{DevContainer Analysis and Evaluation}\label{sec::eval}
The following section discusses the usability of DevContainers and compares them to alternative development solutions. The metrics considered for this comparison are described below. These are used in order to evaluate the usability and to determine the success of the applied concept.

    \subsection{Considered Metrics}
    The evaluation is divided into two sections. First, it is examined whether DevContainers were able to solve the problems described in section \ref{sec::problem}. Second, DevContainers are compared to alternative solutions, some of which have only recently been released. For this purpose, the alternatives described in section \ref{ssec::alternatives} are taken into account.\newline
    For the evaluation of the Symbic DevContainer prototype, several metrics are taken into consideration. One of the first things to look at is the number of steps needed in order to perform a full deployment of all necessary components to set up a developers machine for development. This approximates the expected effort for new developers to get a working project setup. Doing so, platform-specific steps are considered as well, so is the choice of available (development) software. Subsequently, the interaction with the environment is analyzed. The usability of the environments is considered as well, the decisive factor is the free choice of editors and interaction possibilities with the application to be developed. The system-load analysis clarifies whether the properties of the DevContainers have a significant impact on the development process. Finally, the error behavior, (dependency) configuration setup, reproducibility capabilities and available testing possibilities are considered. \newline
    The function rage and control capabilities represent the main points of comparison when contrasting DevContainers with the alternative development environments mentioned in section \ref{ssec::alternatives}. This includes several aspects, such as the control over the environment, supported programming languages, the type of service provision and the pricing model.

    \subsection{Evaluation and Results}\label{sses::eval_compare}
    This section examines the points mentioned above concerning the metrics and data collection. This examination is divided into two sections. First, the findings for the prototype implementation of the DevContainer concept is evaluated. The native development environment is directly contrasted with the DevContainer environment. Then, the DevContainer environment is, albeit only argumentatively, compared to, both browser-based and container-based, alternative solutions. A direct comparison between DevContainers and the alternatives was not possible, due to lack of access to the full function range of the alternatives and agreement enclose for the project source code.

        \subsubsection{Evaluation for the Prototype Implementation}\label{sss::eval_proto}
        The following section is an evaluation of the applied DevContainer concept with respect to the problems described in section \ref{sec::problem}.

        \myparagraph{The Initial Setup Process}
        The initial setup process is significantly simplified using DevContainer. Databases and auxiliary services are provided by isolated containers, so there is no need to install them manually. Language runtimes, compilers and dependencies are provided with the DevContainers images. The specific versions of every software used are stored as code, so that, similar to the \ac{PaaS} principle, the entire development environment is made available as a uniform platform. There is only one uniform way for software installation.\newline
        Table \ref{tab::init_steps} shows a comparison of all the steps, which need to be performed by new developers in order to create a working environment. The initial cloning process of the repositories and installation of an editor is necessary in both approaches, but while the native development approach requires all program components to be installed individually, the DevContainer environment only requires Docker to be installed. Accordingly, in this example less than half of the steps are necessary in order to set up a development environment. Table \ref{tab::init_steps} also takes into account whether the respective steps are independent of the \acl{OS}. All (dark) green highlighted steps are independent of the operating system used. The steps displayed with a gray background are operating system specific and are therefore potentially different for each \ac{OS} and, additionally, more prone to errors.\newline
        Thus, DevContainers make it easier and more efficient to set up a new working environment. The runtime and settings of all applications are in a defined good state, independent of the host system and without conflicts to other projects. After installing Docker, multiple applications can be started simultaneously by executing \code{docker-compose up}.
        \input{inc/table_init.inc}

        \myparagraph{Dependency Management}
        Due to the firmly defined Dockerfiles, the version of the programming languages used is always consistent among all developers. Errors caused by different library versions are thus avoided. If a new major program version is to be tested, developers can simply set the \code{VARIANT} variable accordingly and restart the DevContainer with the \code{-{}-build} flag of Docker Compose (\code{docker-compose up -{}-build}). A new image is crated automatically and the application is launched with the new runtime without affecting other applications, projects or the host. This strict isolation of individual software versions greatly simplifies the simultaneous operation of multiple versions and prevents errors. Working on different projects with conflicting dependencies is thus made possible.\newline
        In case an error occurs anyway, it can be fixed quickly by discarding the existing DevContainer, reverting all changes and recreating a new container from a known good image. Changes to the source code are not lost, since these are stored on the host and are made available by bind-mount in the container. Since all relevant configurations are tracked in \ac{VCS}, changes can be quickly detected and be undone.\newline
        The number of possible problems is significantly reduced by the use of DevContainers. Furthermore, the DevContainer environment is quite similar to the configuration in productive operation. Operating system specific errors, such as different file system separators, line endings and libraries that may behave differently between Linux and Windows, are avoided. Developers can focus on new features for an application and do not have to consider as many edge cases when running and testing their application.

        \myparagraph{Lack of Testing Options}
        A major challenge of a microservice architecture is the increased configuration overhead between applications and the associated lack of testing possibilities for the entire service. Apart from unit tests, developers can not test the successful integration of individual applications due to the immense configuration effort. This is why this job is often performed by \ac{CI} systems. However, these systems can only detect errors after the code has been pushed to the \ac{VCS} system and all, possibly lengthy, tests have been completed. This late detection of errors slows down the development process and increases its cost.\newline
        However, thanks to DevContainers and the orchestration of individual services by Docker Compose, all relevant applications can be launched simultaneously, and are preconfigured to successfully interact with each other. Within a short time, developers can test whether cross-application communication is successful and can reproduce user processes in concrete terms. Thus, end-to-end tests can already be performed on the developers' machines. Errors can be detected before the code is checked into the \ac{VCS} and can hence be fixed earlier. Through the use of containers, even more comprehensive testing tools are available.\newline
        Yet, the concept of DevContainers do not replace testing conducted by the \ac{CI}. Load tests and acceptance tests cannot be carried out on the developer's systems, since its results have no relevant significance.
        % Besides, the solution presented here does not provide communication via HTTPS. Certificate-related errors can therefore not be avoided by DevContainers.

        \myparagraph{Performance Evaluation}
        Although containers have a significantly lower performance overhead than \ac{VM}s \cite{ieee_perfomance}, a performance loss is still noticeable when using the implemented prototype from above. To quantify this, performance metrics of the individual applications from the prototype were collected and the difference between direct execution on the host and execution in the container were considered.\newline
        The evaluation was performed on a laptop with an Intel Core i5-10210U CPU, 16 GB of RAM and an NVMe SSD. Windows 10 Pro 21H1 and Debian 11 (Bullseye) were used as the testing operating systems. On Windows, the running processes were written to a log file with the command line tool \code{Get-Process} every 10 seconds for a duration of 30 minutes. When using Docker Desktop (Version 20.10.8), the tool \code{docker stats} was also used to obtain the resources used per container in addition to \code{Get-Process}. On Linux, the \code{top} program was used to monitor the processes for the same duration, and \code{docker stats} was used again when running the applications inside \code{docker-ce} (Version 20.10.9). The link to the entire evaluation script can be found in the appendix. The results were then processed and the arithmetic averages are shown in Table \ref{tab::eval_win} and \ref{tab::eval_linux}.\newline
        Considering the results for Windows (Table \ref{tab::eval_win}), the sum of the individual process load of all applications running directly on the host (NodeJS, MariaDB, Apache) is larger than the load of the Docker process when running the same applications as containers (25\% vs 15\%). The approximately 13\% CPU usage from the combined containers matches the 15\% usage of the Docker process except for a few percent overhead. Contrary to this, two of the three containerized applications consume more RAM than when running directly on the host. Docker's usage of 4 GB of RAM can be explained by a setting in \ac{WSL}. Since Windows has to virtualize the Linux kernel, the micro \ac{VM} uses all the available memory allocated to it, even if the individual containers, with a commutated demand of 300 MB, do not actively use all the available RAM.\newline
        The performance results on Linux barley show any differences wherever the application in directly executed on the host and or inside a container. The CPU utilization is exactly the same and even the RAM usage is quiet similar. The lower RAM usage of the Apache webserver within the container by be caused because the container image has fewer plugins enabled by default. The overhead of the docker engine is less than 200 MB RAM and about 1\% CPU utilization. When comparing the results from Windows and Linux, it is noticeable that not only the overhead of the Docker-Engine is significantly lower, but the container processes also use significantly fewer CPU resources under Linux. The use of DevContainer under Linux was indistinguishable from the native execution of the processes. The main reason for this is probably the specific optimization of Docker for Linux and, in contrast to Windows, the omission of the kernel to be emulated.\newline
        In addition to the CPU and RAM usage, the read and write speed of the disk was also considered. While the installation of npm packages on Linux was almost identical when and when not using docker, there are significant differences under Windows. The direct installation of npm packages on the host was twice as fast as the installation in the container using bind-mounts. Using volumes for the packages, as suggested in section \ref{sec::solution_code}, the installation was still 50\% slower than without using DevContainers. It is the poor I/O performance when using many small files, such as npm packages, that is the biggest limitation of using DevContainers on Windows. The usage of 20 containers, on the hardware described above, CPU and RAM resources have not been the limiting factor under Windows. Only the poor NTFS file system performance in combination with the Docker overlay-filesystem and the aggressive scanning behavior of the Windows integrated virus scanner made for a slower user experience in practice. On Linux, no limitations could be found in terms of performance.
        \input{inc/table_eval.inc}

    \subsubsection{Comparison to Alternative Development Solutions}
    While the concept of a local containerized development setup is new, the existence of alternative approaches is not. The solution presented in this paper is compared to browser-based and container-based development environments of various vendors. The results of the following comparison is summarized in Table \ref{tab::env_compare} at the end of this section. The evaluation is based on the available documentation and experiences made while testing these solutions at the time of writing this thesis.

        \myparagraph{Comparison to browser-based Development Solutions}
        The major distinction between the solutions presented in this thesis and browser-based development environments is the scope of supported programming languages. The alternatives Codesandbox.io and Stackblitz, mentioned in section \ref{ssec::alternatives}, only support NodeJS projects based on JavaScript or its superset TypeScript. Accordingly, the choice of programming languages is very limited, as is the ability to run multiple services in parallel. Both services lack the possibility of orchestration and the possibility to install any additional utilities, which greatly limits the control and therefore the features of these services. \newline
        Furthermore, not all functions of NodeJS are supported. External packages based on native \ac{OS} libraries or binaries, like the popular task-runner \code{grunt}, often do not work. This is especially true for packages based on encryption libraries, like the \ac{SSH}-client \code{ssh2}. Control over created network sockets is either missing or limited by the browser runtime. A command-line interface is also missing (Codesandbox.io) or very limited (Stackblitz). Both solutions do not support debugging. Due to the nature of a browser window, the available space and input methods to the editor are limited, due to an omnipresent preview window and, in addition to that, common key combinations, such as \code{F1} collide with the browsers keyboard shortcuts.\newline
        The advantage of this solution is that users have a working setup within seconds, due to the variety of available templates. Users can edit code from any device without the need to install any additional programs, because these alternatives run in the browser. This makes this solution attractive for teaching purposes and fast prototyping of frontend projects.\newline
        Since Codesandbox.io, unlike StackBlitz, runs the code on their servers, Codesandbox.io has access to the entire source code and network traffic, which may violate confidentiality clauses. Their free pricing model only allows for publicly accessible development sessions and does not support private \code{npm} package repositories. Paid sessions vary from \$9 to \$39 for Stackblitz and \$30 to \$50 for Codesandbox.io per user per month \cite{stackblitz}, \cite{codesandbox}. \newline
        These solutions also try to solve problems in modern development environments, but limit themselves to a specific scope. The limitations listed here show that only small NodeJS projects or purely frontend projects can be implemented with Codesandbox.io and Stackblitz. This is also supported by the fact that the majority of templates are built for frontend frameworks. The narrower support for backend features and the missing support for auxiliary services make these alternatives not suitable for professional development.

        \myparagraph{Comparison to container-based Development Solutions}
        The alternative container-based development environments Codespaces and Gitpod show distinct similarities to the solution presented in this thesis. Both solutions rely on the isolated provisioning of predefined runtime environments via container-based virtualization. These environments are likewise built upon a Linux kernel and can thus provide a development environment for any programming language supported on Linux. At the time of writing, projects requiring a Windows or macOS host are not supported.\newline
        Gitpod is integrated in various \ac{VCS}-providers and offers the possibility to create a \ac{VSCode} instance within the browser. A local \ac{VSCode} instance can also be used in order to connect to a running container, which bypasses the limited keyboard shortcut support of a browser. Codespaces offers the same possibility, except that this service only works with \href{https://www.GitHub.com}{GitHub.com}. Within a container, developers have full control over the system. Additional applications can be installed, debugging is possible and ordinary TCP/UDP ports can be exposed to the internet or to a connected \ac{VSCode} client. Codespaces, Gitpod and the DevContainers require that the container environment must be manually defined and optimized once. The time required is determined by the size and complexity of the project.\newline
        However, Codespaces and Gitpod differ in the way individual applications are organized. Both alternatives focus on the provision of one development environment for one application, while the DevContainer concept specializes in the simultaneous usage and interaction of multiple applications. While one container can contain any number of services, this makes the container bulkier, more resources hungry, and less reusable. Generally, containers are intended to run one application only, additional applications should be available via \ac{API}s, this makes containers lightweight and flexible. While Codespaces can enable a development environment for massive applications like the monolithically structured \href{https://www.GitHub.com}{GitHub.com} service (13 GB repository, built-in \ac{DB} and many dependencies) when given 32 CPU cores and 64 GB RAM \cite{githubblogcodespace}, this is not the most efficient and flexible solution since this approach requires many rebuilds if a container changes. Often developers only need to work on one part of a project, so that the massive compute resources are not needed. In particular, GitHub struggled with these massive containers primarily because of the deployment time of their containers, yet, through intense and extensive optimization, their developers were able to reduce the Codespace creation time from 45 minutes to less than a minute. This was only possible because their \ac{CI} constantly builds new, updated container images so that there is always a buffer with ready to deploy images. These immense computing resources are not available in smaller companies. The provisioning time of the DevContainer solution is about 10 seconds, provided that the images are already downloaded once. Another difference is that the solution presented here allows a hybrid operation between local applications and DevContainer applications. This is not supported by Codespaces and Gitpod. Companies are confronted with the major decision on whether to invest heavily into one service and lack the option to switch gradually to a new development strategy.\newline
        Furthermore, the presented solutions differ in respect of the choice of the available editors. Although the use of \ac{VSCode} is recommended for DevContainers, the use of any other editor is possible, unlike with Codespaces and Gitpod. With Codespaces and Gitpod, the container infrastructure is provided by the respective providers, which is why a permanent Internet connection is required and the compliance with confidentiality agreements must be fulfilled. Both services also offer options for self-hosting, but these are only included in the higher-priced subscriptions and still do not run on the developers machines. Free versions of these services either offer only limited computing time, such as 50 hours per month at Gitpod, or the computing capacity used is billed per minute. The paid offerings range per month and user from \$9 to \$39 for Gitpod and from \$4 to \$21 for Codespaces. The DevContainer solution presented here is free on Linux and free on Windows and macOS as long as the company size does not exceed 250 employees or a turnover of \$10 million when using Docker Desktop. Beyond these numbers, Docker Desktop prices vary between \$5 and \$21 per month and per user \cite{gitpod}, \cite{githubblogcodespace}.\newline
        Structurally, all three solutions are similar in various points, the usability of Codespaces is superior due to its direct integration in \href{https://www.GitHub.com}{GitHub.com} and the resulting comfort. The massive hardware resources of Codespaces and Gitpod are not comparable to those of a local workstation. The biggest disadvantage of these solutions is the dependence on external service providers and the associated significantly higher costs. The existence of these solutions and the increasing number of providers conclude the potential of efficient and uniform development environments. Codespaces has only been officially presented during the preparation of this work (August 2021) and is still at an early stage.
        The choice for the most suitable solution for a specific project depends on the respective requirements. Since none of the three solutions relies on proprietary configuration files, the same Dockerfiles can be used for DevContainer, Codespaces and Gitpod. This enables easy migration between these solutions.

    \subsection{Summarized Evaluation}
    As seen above, DevContainers offer a tremendous opportunity to solve problems during the development process. Development environments become more isolated, uniform and much easier to set up and maintain. Commercial solutions such as Codespaces and Gitpod show that these companies see potential in using pre-defined development environments.\newline
    The solution presented in this thesis is able to solve the problems described in section \ref{sec::problem} to a large extent and therefore can be classified as successful. Although the creation of a DevContainer environment increases the configuration effort in the short term, in the long term fewer different configurations setups need to be supported. The performance evaluation has shown that Docker introduces a performance overhead on Windows, nevertheless applications, executed on Linux often require less CPU capacity compared to Windows. On modern computers with sufficient memory, running multiple applications on Windows is possible without any real limitations. Only the I/O performance of the storage-device is a limiting factor, which is why fast SSDs should be used. On Linux, no limitations could be found in terms of performance. \newline
    The possibilities of virtualization in development are enormous. Suddenly, a much larger selection of programs, which are already preconfigured, is available. Even if DevContainers are not used for the applications developed, the platform independent, simple provisioning of databases and auxiliary services is an immense advantage.

    \myparagraph{Possible Improvements}
    Docker enables access to software, which were previously exclusively available in the server world. This software allows to further improve the concept presented above. Instead of directly exposing application ports, a reverse proxy can be placed in front of every application. Only the port of the proxy is then exposed to the host. This allows developers to access their frontend by requesting \code{frontend.myapp}. The proxy than automatically forwards the requests to the appropriate application. Accordingly, Developers do not need to remember application ports or have to pay attention to port collisions on \code{localhost}. The reverse proxy routes all requests thought the internal docker network to the appropriate application. This is another strategy that is often used in a production environment, making the DevContainer environment even more similar to the production one. Furthermore, to minimize the load on the developer's machine, static services can be made available on a shared company-internal servers. The MQTT-broker or the \ac{SSH} server may not be needed on every machine and can be shared.
