% !TeX root = ../thesis_main.tex

\section{DevContainer Analysis and Evaluation}\label{sec::eval}
The following section discusses the usability of DevContainers and compares them to alternative virtualization-based development solutions. The metrics considered for this comparison are described below and are then contrasted to evaluate the usability and therefore to determine the success of the applied concept to the problem described in this thesis.

    \subsection{Considered Metrics}
    The evaluation is divided into two sections. First, it is examined whether DevContainers were able to solve the problems described in section \ref{sec::problem}. Second, the impact of the challenges encountered during the prototype implementation and the overall usability is analyzed. Subsequently, DevContainers are compared to alternative solutions, some of which have only recently been published. For this purpose, the alternatives described in section \ref{ssec::alternatives} are taken into account.\newline
    For the evaluation of the DevContainer prototype in the Symbic project, several metrics are taken into consideration. One of the first things to look at is the number of steps needed in order to perform a full deployment of all necessary components to set up a developer's machine for development. This approximates the expected effort for new developers to get a working project setup. Doing so, platform-specific steps are also considered as well as the choice of available (development) software. Subsequently, the interaction with the environment is analyzed. The usability of the environments is considered as well, the decisive factor is the free choosing of the editor and interaction possibilities with the application to be developed. The system-load analysis clarifies whether the properties of the DevContainers have a significant impact on the development process. Finally, the behavior in case of error, (dependency) configuration, reproducibility and available testing possibilities are considered. \newline
    The range of functions represents the main point of comparison when contrasting DevContainers with the alternative development environments mentioned in section \ref{ssec::alternatives}. This range includes several aspects, such as the control over the environment, supported programming languages, the type of service provision and the pricing model.

    \subsection{Evaluation and Results}\label{sses::eval_compare}
    This section examines and evaluates the points mentioned above concerning the metrics and data collection. This examination is divided into two sections. First, the findings for the prototype implementation of the DevContainer concept is evaluated. The native development environment is directly contrasted with the DevContainer environment. Then, the DevContainer environment is, albeit only argumentatively, compared to, both browser-based and container-based, alternative solutions. A direct comparison between DevContainers and the alternatives was not possibile, due to lack of access to the full function range of the alternatives and agreement enclose for the project source code.

        \subsubsection{Evaluation for the Prototype Implementation}
        The following is an evaluation of the success of the DevContainer with respect to the problems described in section \ref{sec::problem}.

        \myparagraph{The Initial Setup Process}
        The initial setup process is significantly simplified using DevContainer. Databases and auxiliary services are provided by isolated containers, so there is no need to install them manually. Language runtimes, compilers and dependencies are provided with the DevContainers images. The specific versions of every software used are stored as code, so that, similar to the \ac{PaaS} principle, the entire development environment is made available as a uniform platform.\newline
        Table \ref{tab::init_steps} shows a comparison of all the steps, which need to be performed by new developers in order to create a working environment. The initial cloning process of the repositories and installation of an editor is necessary in both approaches, but while the native development approach requires all program components to be installed individually, the DevContainer environment only requires Docker to be installed. Accordingly, less than half of the steps are necessary in order to set up a DevContainer environment. Table \ref{tab::init_steps} also takes into account whether the respective steps are independent of the \acl{OS}. All steps highlighted with a (dark) green background are independent of the operating system used. The steps displayed with a gray background are operating system specific and are therefore potentially different for each \ac{OS} and, additionally, more prone to errors.\newline
        Thus, DevContainers make it easier and more efficient to set up a new working environment. The runtime and settings of all applications are in a defined good state and independent of the host system. After installing Docker, all applications can be started by calling \code{docker-compose up}.
        \input{inc/table_init.inc}

        \myparagraph{Dependency Management}
        Due to the firmly defined Dockerfiles, the version of the programming languages used is always consistent among all developers. Errors caused by different versions of libraries are thus avoided. If a new major program version is to be tested, developers can simply set the \code{VARIANT} variable accordingly and restart the DevContainer with the \code{-{}-build} flag of Docker Compose (\code{docker-compose up -{}-build}). A new image is crated automatically and the application is launched with the new runtime without affecting other applications or the host. This strict isolation of individual software versions greatly simplifies the simultaneous operation of multiple versions and prevents errors. Working on different projects with conflicting dependencies is thus made possible.\newline
        In case a configuration error occurs anyway, it can be fixed quickly by discarding the existing DevContainer, reverting all changes and recreating a new container from a known good image. Changes to the source code are not lost, since these are stored on the host and are available by bind-mount in the container. Since all relevant configurations are tracked in \ac{VCS}, changes can be quickly detected and be undone.\newline
        The number of possible problems is significantly reduced by the use of DevContainer. Furthermore, the DevContainer environment is quite similar to the configuration in productive operation. Operating system specific errors, such as different file system separators, line endings and libraries that may behave differently between Linux and Windows, are avoided. Developers can focus on new features for an application and do not have to consider as many edge cases when running their application.

        \myparagraph{Lack of Testing Options}
        A major challenge of a microservice architecture is the increased configuration overhead between applications and the associated lack of testing possibilities for the entire service. Apart from unit tests, developers can not test the successful integration of individual applications due to the immense configuration effort. This is why this job is often performed by \ac{CI} systems. However, these systems can only detect errors after the code has been pushed to the \ac{VCS} system and all, possibly lengthy, tests have been completed. This late detection of errors slows down the development process and increases its cost.\newline
        However, thanks to DevContainers and the orchestration of individual services by Docker Compose, all relevant applications can be launched simultaneous, and they are preconfigured to interact with each other. Within a short time, developers can test whether cross-application communication is successful and can reproduce user processes in concrete terms. Thus, end-to-end tests can already be performed on the developers' machines. Errors can be detected before the code is checked into the \ac{VCS} and can hence be fixed earlier. Through the use of containers, even more comprehensive testing tools may be available.\newline
        However, the concept of DevContainers do not replace testing conducted by the \ac{CI}. Load tests and acceptance tests cannot be carried out on the developer's computer, since its results have no relevant significance. Besides, the solution presented here does not take the communication via HTTPS into account. Certificate-related errors will therefore not be avoided by DevContainer.

        \myparagraph{Performance Evaluation}
        ToDo

        % ToDo Move to outlook
        \myparagraph{Further Potential and Possible Improvments}
        Docker enables access to software, which were previously exclusively available in the server world. This software allows to further improve the concept presented here. Instead of directly exposing application ports, a reverse proxy can be placed in front of every application. Only the port of the proxy is then exposed to the host. This allows developers to access their frontend by requesting \code{forntend.myapp}. The proxy than automatically forwards the requests to the appropriate application. Accordingly, Developers do not need to remember application ports or have to pay attention to port collisions on \code{localhost}. The reverse proxy routes all requests thought the internal docker network to the appropriate application. Furthermore, to minimize the load on the developer's machine, static services can be made available on a shared internal server within the company. The MQTT-broker or the \ac{SSH} server may not be needed on every machine and can be shared. There is also room for improvement in the interaction of non-Linux host systems with the containers. Investing work in improving support for Windows file-systems could have a big impact on performance.


    \subsubsection{Comparison to Alternative Development Solutions}
    The evaluation is based on the available documentation and experiences made while testing these solutions at the time of writing this thesis. The solution presented in this paper is compared to browser-based and container-based development environments of various vendors. The results of the following comparison is summarized in Table \ref{tab::env_compare} at the end of this section.

        \myparagraph{Comparison to browser-based Development Solutions}
        The major distinction between the solutions presented in this thesis and browser-based development environments is the scope of supported programming languages. The alternatives Codesandbox.io and Stackblitz, as they are presented above, only support NodeJS projects based on JavaScript or its superset TypeScript. Accordingly, the choice of programming languages is limited, as is the ability to run multiple services in parallel. Both services lack the possibility of orchestration as well as the possibility to install any additional utilities, which greatly limits the control and therefore the features of these environments. \newline
        Furthermore, not all functions of NodeJS are supported. External packages based on native \ac{OS} libraries or binaries, like the popular task-runner \code{grunt}, often do not work. This is especially true for packages based on encryption, like the \ac{SSH}-client \code{ssh2}. Control over created network sockets is either missing or limited by the browser runtime. A command-line interface is also missing (Codesandbox.io) or very limited (Stackblitz). Both solutions do not support debugging. Due to the nature of a browser window, the available space and input methods to the editor are limited, due to an omnipresent preview window and, in addition to that, common key combinations, such as \code{F1} collide with the browsers keyboard shortcuts.\newline
        The advantage of this solution is that users have a working setup within seconds, due to the variety of available templates. Users can edit code from any device without the need to install any additional programs, because these alternatives run in the browser. This makes this solution attractive for teaching purposes and fast prototyping of frontend projects.\newline
        Since Codesandbox.io, unlike StackBlitz, runs the code on their servers, Codesandbox.io has access to the entire source code and network traffic, which may violate confidentiality clauses. Their free pricing models only allow for publicly accessible development sessions and does not support private \code{npm} package repositories. Paid sessions vary from \$9 to \$39 for Stackblitz and \$30 to \$50 for Codesandbox.io per user per month \cite{stackblitz}, \cite{codesandbox}. \newline
        These solutions also try to solve problems in modern development environments, but limit themselves to a specific scope. The limitations listed here show that only small NodeJS projects or purely frontend projects can be implemented with Codesandbox.io and Stackblitz. This is also supported by the fact that the majority of templates are built for frontend frameworks. The narrower support for backend features and the missing support for auxiliary services make these alternatives not suitable for professional development.

        \myparagraph{Comparison to container-based Development Solutions}
        The alternative container-based development environments Codespaces and Gitpod show distinct similarities to the solution presented in this thesis. Both solutions rely on the isolated provisioning of predefined runtime environments via container-based virtualization. These environments are likewise built upon a Linux kernel and can thus provide a development environment for any programming language supported on Linux. At the time of writing, projects requiring a Windows or macOS host are not supported.\newline
        Gitpod is integrated in various \ac{VCS}-providers and offers the possibility to create a \ac{VSCode} instance within the browser. A local \ac{VSCode} instance can also be used in order to connect to a running container, which bypasses the limited keyboard shortcut support of an browser. Codespaces offers the same possibility, except that this service only works with \href{https://www.GitHub.com}{GitHub.com}. Within the containers, developers have full control over the system. Additional applications can be installed, debugging is possible and ordinary TCP/UDP ports can be exposed to the internet or to a connected \ac{VSCode} client. Codespaces, Gitpod and the DevContainers require that the container environment must be manually defined and optimized once. The time required is determined by the size and complexity of the project.\newline
        However, Codespaces and Gitpod differ in the way individual applications are organized. Both alternatives focus on the provision of one development environment for one application, while the DevContainer concept specializes in the simultaneous usage and interaction of multiple applications. While one container can contain any number of services, this makes the container bulkier, more power hungry, and less reusable. Containers are intended to run one application only, additional applications are available via \ac{API}s, which makes the containers lightweight and flexible. While Codespaces can enable a development environment for massive applications like the monolithically structured \href{https://www.GitHub.com}{GitHub.com} service (13 GB repository, built-in \ac{DB} and many dependencies) when given 32 CPU cores and 64 GB RAM \cite{githubblogcodespace}, this is not the most efficient and flexible solution. Often developers need to work on one part of a project, so that the massive compute resources are not needed. GitHub struggled primarily with the deployment time of their container, yet, through intense and extensive optimization, their developers were able to reduce the Codespace creation time from 45 minutes to less than a minute. The provisioning time of the DevContainer solution is about 10 seconds, provided that the images have already been downloaded once. Another difference is that the solution presented here allows a hybrid operation between local applications and DevContainer applications. This is not supported by Codespaces and Gitpod. Companies are confronted with the major decision on whether to invest heavily into one service and lack the option to switch gradually to a new development strategy.\newline
        Furthermore, the presented solutions differ in respect of the choice of the available editors. Although the use of \ac{VSCode} is recommended for DevContainers, the use of any other editor is possible, unlike with Codespaces and Gitpod. With Codespaces and Gitpod, the container infrastructure is provided by the respective providers, which is why a permanent Internet connection is required and the compliance with confidentiality agreements must be fulfilled. Both services also offer options for self-hosting, but these are only included in the higher-priced subscriptions and still do not run on the developers machines. Free versions of these services either offer only limited computing time, such as 50 hours per month at Gitpod, or the computing capacity used is billed per minute. The paid offerings range per month and user from \$9 to \$39 for Gitpod and from \$4 to \$21 for Codespaces. The DevContainer solution presented here is free on Linux and free on Windows and macOS as long as the company size does not exceed 250 employees or a turnover of \$10 million when using Docker Desktop. Beyond these numbers, prices are charged between \$5 and \$21 per month and per user \cite{gitpod}, \cite{githubblogcodespace}.\newline
        Structurally, all three solutions are similar in various points, the usability of CodeSpaces is superior due to its direct integration in \href{https://www.GitHub.com}{GitHub.com} and the resulting comfort. The massive hardware resources of Codespaces and Gitpod are not comparable to those of a developer workstation. The biggest disadvantage of these solutions is the dependence on an external service provider and the associated significantly higher costs. The existence of these solutions and the increasing number of providers conclude the potential of efficient and uniform development environments. Codespaces has only been officially presented during the preparation of this work and is still at an early stage.
        The choice of the most suitable solution for a specific project from the ones presented in this paper depends on the respective requirements. Since none of the three solutions relies on proprietary configuration files, the same Dockerfiles can be used for DevContainer, Codespaces and Gitpod. This enables easy migration between these solutions.

    \subsection{Summarized Evaluation}
    As seen above, DevContainers offer a tremendous opportunity to solve problems during development time. Development environments become more isolated, uniform and much easier to set up and maintain. The commercial solutions such as Codespaces and Gitpod show that these companies see potential in using pre-defined development environments.\newline
    The solution presented in this thesis is able to solve the problems described in section \ref{sec::problem} to a large extent and therefore can be classified as successful. Although the creation of a DevContainer environment increases the configuration effort in the short term, in the long term fewer different configurations setups need to be supported. \newline
    The possibilities of virtualization in development are enormous. Suddenly, a much larger selection of programs, which are already preconfigured, is available. Even if DevContainers are not used for the applications developed, the platform independent, simple provisioning of databases and auxiliary services is an immense advantage.
